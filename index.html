<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Urban Solar Potential – Chania</title>

<script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
<link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet"/>

<script src="https://unpkg.com/deck.gl@8.9.34/dist.min.js"></script>

<style>
body { margin:0; overflow:hidden; background:#000; font-family:system-ui; }
#map { width:100vw; height:100vh; }

.panel {
  position:absolute;
  background:rgba(15,15,15,0.92);
  color:#ddd;
  padding:12px;
  border-radius:4px;
  font-size:12px;
  z-index:10;
}

#metadata { bottom:20px; left:20px; width:320px; }
h3 { margin:0 0 6px 0; color:#fff; font-size:14px; }
</style>
</head>

<body>

<div id="map"></div>

<div id="metadata" class="panel">
  <h3>Urban Solar Potential – Chania</h3>
  <p>
    Solar irradiation shown as surface color.
    Buildings extruded for urban context.
  </p>
  <p><strong>Unit:</strong> kWh/m²/year</p>
</div>

<script>

// -----------------------------------------------------------------------------
// Map Setup – Direct zoom to Chania
// -----------------------------------------------------------------------------

const map = new maplibregl.Map({
  container: 'map',
  style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
  center: [24.018, 35.513],   // Chania
  zoom: 15.5,
  pitch: 60,
  bearing: -20,
  antialias: true
});

map.addControl(new maplibregl.NavigationControl());


// -----------------------------------------------------------------------------
// Generate Solar Surface Grid (Demo values for Chania)
// -----------------------------------------------------------------------------

function generateSolarSurface() {
  const features = [];
  const step = 0.002; // small cells for city scale

  for (let lon = 23.99; lon <= 24.05; lon += step) {
    for (let lat = 35.49; lat <= 35.54; lat += step) {

      const base = 1700;
      const gradient = (35.54 - lat) * 200;
      const value = base + gradient + Math.random() * 50;

      const polygon = [
        [lon, lat],
        [lon + step, lat],
        [lon + step, lat + step],
        [lon, lat + step],
        [lon, lat]
      ];

      features.push({
        type: "Feature",
        properties: { solar: Math.round(value) },
        geometry: {
          type: "Polygon",
          coordinates: [polygon]
        }
      });
    }
  }

  return {
    type: "FeatureCollection",
    features: features
  };
}

const solarGeoJSON = generateSolarSurface();

let overlay = null;

map.on('load', () => {

  // ---------------------------------------------------------------------------
  // 3D Buildings
  // ---------------------------------------------------------------------------

  const layers = map.getStyle().layers;
  let labelLayerId;
  for (const layer of layers) {
    if (layer.type === 'symbol' && layer.layout['text-field']) {
      labelLayerId = layer.id;
      break;
    }
  }

  map.addLayer(
    {
      id: '3d-buildings',
      source: 'openmaptiles',
      'source-layer': 'building',
      type: 'fill-extrusion',
      minzoom: 14,
      paint: {
        'fill-extrusion-color': '#666',
        'fill-extrusion-height': [
          'coalesce',
          ['get', 'height'],
          ['*', ['get', 'levels'], 3],
          8
        ],
        'fill-extrusion-base': 0,
        'fill-extrusion-opacity': 0.85
      }
    },
    labelLayerId
  );

  // ---------------------------------------------------------------------------
  // Solar Surface Layer (2D colored)
  // ---------------------------------------------------------------------------

  const solarLayer = new deck.GeoJsonLayer({
    id: 'solar-surface',
    data: solarGeoJSON,
    filled: true,
    stroked: false,
    getFillColor: d => {
      const v = d.properties.solar;
      if (v > 1800) return [255, 120, 0, 160];
      if (v > 1700) return [255, 170, 0, 140];
      return [255, 230, 120, 120];
    },
    pickable: true,
    onClick: ({object}) => {
      if (!object) return;
      alert(`Solar potential: ${object.properties.solar} kWh/m²/year`);
    }
  });

  overlay = new deck.MapboxOverlay({
    layers: [solarLayer]
  });

  map.addControl(overlay);
});

</script>

</body>
</html>
